From b910a9823d540f7c4d8a07e56384d420ea0b3bc1 Mon Sep 17 00:00:00 2001
From: Konsta <konsta09@gmail.com>
Date: Sat, 12 Apr 2014 14:08:22 +0300
Subject: [PATCH 1/5] Revert "dtbtool: Add qcom,board-id support (version 2)"

This reverts commit 30576c9006dd9a816087bb398a5979bd9023f9d8.
---
 dtbtool/dtbtool.c   |  391 +++++++++------------------------------------------
 dtbtool/dtbtool.txt |   45 ++----
 2 files changed, 80 insertions(+), 356 deletions(-)

diff --git a/dtbtool/dtbtool.c b/dtbtool/dtbtool.c
index 804dd5d..93d9076 100644
--- a/dtbtool/dtbtool.c
+++ b/dtbtool/dtbtool.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
@@ -41,10 +41,9 @@
 #include <unistd.h>
 
 #define QCDT_MAGIC     "QCDT"  /* Master DTB magic */
-#define QCDT_VERSION   2       /* QCDT version */
+#define QCDT_VERSION   1       /* QCDT version */
 
 #define QCDT_DT_TAG    "qcom,msm-id = <"
-#define QCDT_BOARD_TAG "qcom,board-id = <"
 
 #define PAGE_SIZE_DEF  2048
 #define PAGE_SIZE_MAX  (1024*1024)
@@ -61,7 +60,6 @@
 struct chipInfo_t {
   uint32_t chipset;
   uint32_t platform;
-  uint32_t subtype;
   uint32_t revNum;
   uint32_t dtb_size;
   char     *dtb_file;
@@ -75,20 +73,6 @@ struct chipInfo_t {
 
 struct chipInfo_t *chip_list;
 
-struct chipId_t {
-  uint32_t chipset;
-  uint32_t revNum;
-  struct chipId_t *next;
-  struct chipId_t *t_next;
-};
-
-struct chipSt_t {
-  uint32_t platform;
-  uint32_t subtype;
-  struct chipSt_t *next;
-  struct chipSt_t *t_next;
-};
-
 char *input_dir;
 char *output_file;
 char *dtc_path;
@@ -98,7 +82,6 @@ int   page_size = PAGE_SIZE_DEF;
 
 void print_help()
 {
-    log_info("dtbTool version %d\n", QCDT_VERSION);
     log_info("dtbTool [options] -o <output file> <input DTB path>\n");
     log_info("  options:\n");
     log_info("  --output-file/-o     output file\n");
@@ -181,9 +164,7 @@ int chip_add(struct chipInfo_t *c)
             ((c->chipset == x->chipset) &&
              ((c->platform < x->platform) ||
               ((c->platform == x->platform) &&
-               ((c->subtype < x->subtype) ||
-                ((c->subtype == x->subtype) &&
-                 (c->revNum < x->revNum))))))) {
+               (c->revNum < x->revNum))))) {
             if (!x->prev) {
                 c->next = x;
                 c->prev = NULL;
@@ -200,7 +181,6 @@ int chip_add(struct chipInfo_t *c)
         }
         if ((c->chipset == x->chipset) &&
             (c->platform == x->platform) &&
-            (c->subtype == x->subtype) &&
             (c->revNum == x->revNum)) {
             return RC_ERROR;  /* duplicate */
         }
@@ -228,18 +208,11 @@ void chip_deleteall()
     }
 }
 
-/*
-  For v1 Extract 'qcom,msm-id' parameter triplet from DTB
+/* Extract 'qcom,msm-id' parameter triplet from DTB
       qcom,msm-id = <x y z>;
-
-  For v2 Extract 'qcom,msm-id', 'qcom,board-id' parameter double from DTB
-      qcom,msm-id = <x z> i.e chipset, revision number;
-      qcom,board-id = <y y'> i.e platform and sub-type;
  */
-
-struct chipInfo_t *getChipInfo(const char *filename, int *num, uint32_t msmversion)
+struct chipInfo_t *getChipInfo(const char *filename, int *num)
 {
-
     const char str1[] = "dtc -I dtb -O dts \"";
     const char str2[] = "\" 2>&1";
     char *buf, *pos;
@@ -249,13 +222,8 @@ struct chipInfo_t *getChipInfo(const char *filename, int *num, uint32_t msmversi
     int llen;
     struct chipInfo_t *chip = NULL, *tmp;
     uint32_t data[3] = {0, 0, 0};
-    uint32_t data_st[2] = {0, 0};
     char *tok, *sptr = NULL;
-    int i, entryValid, entryEnded;
-    int count = 0, count1 = 0, count2 =0;
-    int entryValidST, entryEndedST, entryValidDT, entryEndedDT;
-    struct chipId_t *chipId = NULL, *cId = NULL, *tmp_id = NULL;
-    struct chipSt_t *chipSt = NULL, *cSt = NULL, *tmp_st = NULL;
+    int i, count = 0, entryValid, entryEnded;
 
     line_size = 1024;
     line = (char *)malloc(line_size);
@@ -288,284 +256,72 @@ struct chipInfo_t *getChipInfo(const char *filename, int *num, uint32_t msmversi
     } else {
         /* Find "qcom,msm-id" */
         while ((llen = getline(&line, &line_size, pfile)) != -1) {
-            if (msmversion == 1) {
-                if ((pos = strstr(line, QCDT_DT_TAG)) != NULL) {
-                    pos += strlen(QCDT_DT_TAG);
-
-                    entryEnded = 0;
-                    while (1) {
-                        entryValid = 1;
-                        for (i = 0; i < 3; i++) {
-                            tok = strtok_r(pos, " \t", &sptr);
-                            pos = NULL;
-                            if (tok != NULL) {
-                                if (*tok == '>') {
-                                    entryEnded = 1;
-                                    entryValid = 0;
-                                    break;
-                                }
-                                data[i] = strtoul(tok, NULL, 0);
-                            } else {
-                                data[i] = 0;
-                                entryValid = 0;
+            if ((pos = strstr(line, QCDT_DT_TAG)) != NULL) {
+                pos += strlen(QCDT_DT_TAG);
+
+                entryEnded = 0;
+                while (1) {
+                    entryValid = 1;
+                    for (i = 0; i < 3; i++) {
+                        tok = strtok_r(pos, " \t", &sptr);
+                        pos = NULL;
+                        if (tok != NULL) {
+                            if (*tok == '>') {
                                 entryEnded = 1;
-                            }
-                        }
-                        if (entryEnded) {
-                            free(line);
-                            pclose(pfile);
-                            *num = count;
-                            return chip;
-                        }
-                        if (entryValid) {
-                            tmp = (struct chipInfo_t *)
-                                      malloc(sizeof(struct chipInfo_t));
-                            if (!tmp) {
-                                log_err("Out of memory\n");
+                                entryValid = 0;
                                 break;
                             }
-                            if (!chip) {
-                                chip = tmp;
-                                chip->t_next = NULL;
-                            } else {
-                                tmp->t_next = chip->t_next;
-                                chip->t_next = tmp;
-                            }
-                            tmp->chipset  = data[0];
-                            tmp->platform = data[1];
-                            tmp->subtype  = 0;
-                            tmp->revNum   = data[2];
-                            tmp->dtb_size = 0;
-                            tmp->dtb_file = NULL;
-                            tmp->master   = chip;
-                            tmp->wroteDtb = 0;
-                            tmp->master_offset = 0;
-                            count++;
+                            data[i] = strtoul(tok, NULL, 0);
+                        } else {
+                            data[i] = 0;
+                            entryValid = 0;
+                            entryEnded = 1;
                         }
                     }
-
-                    log_err("... skip, incorrect '%s' format\n", QCDT_DT_TAG);
-                    break;
-                }
-            } else if (msmversion == 2) {
-                if ((pos = strstr(line, QCDT_DT_TAG)) != NULL) {
-                    pos += strlen(QCDT_DT_TAG);
-
-                    entryEndedDT = 0;
-                    for (;entryEndedDT < 1;) {
-                        entryValidDT = 1;
-                        for (i = 0; i < 2; i++) {
-                            tok = strtok_r(pos, " \t", &sptr);
-                            pos = NULL;
-                            if (tok != NULL) {
-                                if (*tok == '>') {
-                                    entryEndedDT = 1;
-                                    entryValidDT = 0;
-                                    break;
-                                }
-                                data_st[i] = strtoul(tok, NULL, 0);
-                            } else {
-                                data_st[i] = 0;
-                                entryValidDT = 0;
-                                entryEndedDT = 1;
-                            }
-                        }
-
-                        if (entryValidDT) {
-                            tmp_id = (struct chipId_t *)
-                                         malloc(sizeof(struct chipId_t));
-                            if (!tmp_id) {
-                                log_err("Out of memory\n");
-                                break;
-                            }
-                            if (!chipId) {
-                                chipId = tmp_id;
-                                cId = tmp_id;
-                                chipId->t_next = NULL;
-                            } else {
-                                tmp_id->t_next = chipId->t_next;
-                                chipId->t_next = tmp_id;
-                            }
-                            tmp_id->chipset = data_st[0];
-                            tmp_id->revNum= data_st[1];
-                            count1++;
-                        }
+                    if (entryEnded) {
+                        free(line);
+                        pclose(pfile);
+                        *num = count;
+                        return chip;
                     }
-                }
-
-                if ((pos = strstr(line,QCDT_BOARD_TAG)) != NULL) {
-                    pos += strlen(QCDT_BOARD_TAG);
-                    entryEndedST = 0;
-                    for (;entryEndedST < 1;) {
-                        entryValidST = 1;
-                        for (i = 0; i < 2; i++) {
-                            tok = strtok_r(pos, " \t", &sptr);
-                            pos = NULL;
-                            if (tok != NULL) {
-                                if (*tok == '>') {
-                                    entryEndedST = 1;
-                                    entryValidST = 0;
-                                    break;
-                                }
-                                data_st[i] = strtoul(tok, NULL, 0);
-                            } else {
-                                data_st[i] = 0;
-                                entryValidST = 0;
-                                entryEndedST = 1;
-                            }
+                    if (entryValid) {
+                        tmp = (struct chipInfo_t *)
+                                  malloc(sizeof(struct chipInfo_t));
+                        if (!tmp) {
+                            log_err("Out of memory\n");
+                            break;
                         }
-                        if (entryValidST) {
-                            tmp_st = (struct chipSt_t *)
-                                       malloc(sizeof(struct chipSt_t));
-                            if (!tmp_st) {
-                                log_err("Out of memory\n");
-                                break;
-                            }
-
-                            if (!chipSt) {
-                                chipSt = tmp_st;
-                                cSt = tmp_st;
-                                chipSt->t_next = NULL;
-                            } else {
-                                tmp_st->t_next = chipSt->t_next;
-                                chipSt->t_next = tmp_st;
-                            }
-
-                            tmp_st->platform = data_st[0];
-                            tmp_st->subtype= data_st[1];
-                            count2++;
+                        if (!chip) {
+                            chip = tmp;
+                            chip->t_next = NULL;
+                        } else {
+                            tmp->t_next = chip->t_next;
+                            chip->t_next = tmp;
                         }
+                        tmp->chipset  = data[0];
+                        tmp->platform = data[1];
+                        tmp->revNum   = data[2];
+                        tmp->dtb_size = 0;
+                        tmp->dtb_file = NULL;
+                        tmp->master   = chip;
+                        tmp->wroteDtb = 0;
+                        tmp->master_offset = 0;
+                        count++;
                     }
                 }
-            }
-        }
-    }
-
-    if (line)
-        free(line);
 
-    if (count1 == 0) {
-        log_err("... skip, incorrect '%s' format\n", QCDT_DT_TAG);
-        return NULL;
-    }
-    if (count2 == 0) {
-        log_err("... skip, incorrect '%s' format\n", QCDT_BOARD_TAG);
-        return NULL;
-    }
-
-    tmp_st = cSt;
-    while (cId != NULL) {
-        while (cSt != NULL) {
-            tmp = (struct chipInfo_t *)
-                      malloc(sizeof(struct chipInfo_t));
-            if (!tmp) {
-                log_err("Out of memory\n");
+                log_err("... skip, incorrect '%s' format\n", QCDT_DT_TAG);
                 break;
             }
-            if (!chip) {
-                chip = tmp;
-                chip->t_next = NULL;
-            } else {
-                tmp->t_next = chip->t_next;
-                chip->t_next = tmp;
-            }
-
-            tmp->chipset  = cId->chipset;
-            tmp->platform = cSt->platform;
-            tmp->revNum   = cId->revNum;
-            tmp->subtype  = cSt->subtype;
-            tmp->dtb_size = 0;
-            tmp->dtb_file = NULL;
-            tmp->master   = chip;
-            tmp->wroteDtb = 0;
-            tmp->master_offset = 0;
-
-            cSt = cSt->t_next;
-
         }
-        cSt = tmp_st;
-        cId = cId->t_next;
-    }
-
-    if (entryEndedST  == 1 && entryEndedDT == 1) {
+        if (line)
+            free(line);
         pclose(pfile);
-        *num = count1;
-        free(chipSt);
-        free(chipId);
-        return chip;
     }
 
     return NULL;
 }
 
-/* Get the version-id based on dtb files */
-int GetVersionInfo(const char *filename)
-{
-    const char str1[] = "dtc -I dtb -O dts \"";
-    const char str2[] = "\" 2>&1";
-    char *buf, *pos;
-    char *line = NULL;
-    size_t line_size;
-    FILE *pfile;
-    int llen;
-    int v = 1;
-
-    line_size = 1024;
-    line = (char *)malloc(line_size);
-    if (!line) {
-        log_err("Out of memory\n");
-        return 0;
-    }
-
-    llen = sizeof(char) * (strlen(dtc_path) +
-                           strlen(str1) +
-                           strlen(str2) +
-                           strlen(filename) + 1);
-    buf = (char *)malloc(llen);
-    if (!buf) {
-        log_err("Out of memory\n");
-        free(line);
-        return 0;
-    }
-
-    strncpy(buf, dtc_path, llen);
-    strncat(buf, str1, llen);
-    strncat(buf, filename, llen);
-    strncat(buf, str2, llen);
-
-    pfile = popen(buf, "r");
-    free(buf);
-
-    if (pfile == NULL) {
-        log_err("... skip, fail to decompile dtb\n");
-    } else {
-        /* Find the type of version */
-        while ((llen = getline(&line, &line_size, pfile)) != -1) {
-            if ((pos = strstr(line,QCDT_BOARD_TAG)) != NULL) {
-                v = 2;
-                break;
-            }
-        }
-    }
-    if (v == 1)
-        log_info(" Old Version:%d\n", v);
-    free(line);
-
-    return v;
-}
-
-/* Extract 'qcom,msm-id' 'qcom,board-id' parameter from DTB
-   v1 format:
-      qcom,msm-id = <x y z> [, <x2 y2 z2> ...];
-   v2 format:
-      qcom,msm-id = <x z> [, <x2 z2> ...;
-      qcom,board-id = <y y'> [, <y2 y2'> ...;
-   Fields:
-      x  = chipset
-      y  = platform
-      y' = subtype
-      z  = soc rev
- */
 int main(int argc, char **argv)
 {
     char buf[COPY_BLK];
@@ -586,7 +342,6 @@ int main(int argc, char **argv)
     uint32_t version = QCDT_VERSION;
     int num;
     uint32_t dtb_size;
-    int msmversion = 0;
 
     log_info("DTB combiner:\n");
 
@@ -632,27 +387,13 @@ int main(int argc, char **argv)
                 strncpy(filename, input_dir, flen);
                 strncat(filename, dp->d_name, flen);
 
-                /* To identify the version number */
-                msmversion = GetVersionInfo(filename);
-
                 num = 1;
-                chip = getChipInfo(filename, &num, msmversion);
-
-                if (msmversion == 1) {
-                    if (!chip) {
-                        log_err("skip, failed to scan for '%s' tag\n",
-                                QCDT_DT_TAG);
-                        free(filename);
-                        continue;
-                    }
-                }
-                if (msmversion == 2) {
-                    if (!chip) {
-                        log_err("skip, failed to scan for '%s' or '%s' tag\n",
-                                QCDT_DT_TAG, QCDT_BOARD_TAG);
-                        free(filename);
-                        continue;
-                    }
+                chip = getChipInfo(filename, &num);
+                if (!chip) {
+                    log_err("skip, failed to scan for '%s' tag\n",
+                            QCDT_DT_TAG);
+                    free(filename);
+                    continue;
                 }
 
                 if ((stat(filename, &st) != 0) ||
@@ -662,12 +403,12 @@ int main(int argc, char **argv)
                     continue;
                 }
 
-                log_info("chipset: %u, rev: %u, platform: %u, subtype: %u\n",
-                         chip->chipset, chip->revNum, chip->platform, chip->subtype);
+                log_info("chipset: %u, platform: %u, rev: %u\n",
+                         chip->chipset, chip->platform, chip->revNum);
 
                 for (t_chip = chip->t_next; t_chip; t_chip = t_chip->t_next) {
-                    log_info("   additional chipset: %u, rev: %u, platform: %u, subtype: %u\n",
-                             t_chip->chipset, t_chip->revNum, t_chip->platform, t_chip->subtype);
+                    log_info("   additional chipset: %u, platform: %u, rev: %u\n",
+                             t_chip->chipset, t_chip->platform, t_chip->revNum);
                 }
 
                 rc = chip_add(chip);
@@ -686,8 +427,8 @@ int main(int argc, char **argv)
                 for (t_chip = chip->t_next; t_chip; t_chip = t_chip->t_next) {
                     rc = chip_add(t_chip);
                     if (rc != RC_SUCCESS) {
-                        log_err("... duplicate info, skipped (chipset %u, rev: %u, platform: %u, subtype %u:\n",
-                             t_chip->chipset, t_chip->revNum, t_chip->platform, t_chip->subtype);
+                        log_err("... duplicate info, skipped (chipset %u, platform: %u, rev: %u\n",
+                             t_chip->chipset, t_chip->platform, t_chip->revNum);
                         continue;
                     }
                     dtb_count++;
@@ -725,7 +466,7 @@ int main(int argc, char **argv)
 
     /* Calculate offset of first DTB block */
     dtb_offset = 12               + /* header */
-                 (24 * dtb_count) + /* DTB table entries */
+                 (20 * dtb_count) + /* DTB table entries */
                  4;                 /* end of table indicator */
     /* Round up to page size */
     padding = page_size - (dtb_offset % page_size);
@@ -735,7 +476,6 @@ int main(int argc, char **argv)
     /* Write index table:
          chipset
          platform
-         subtype
          soc rev
          dtb offset
          dtb size
@@ -743,7 +483,6 @@ int main(int argc, char **argv)
     for (chip = chip_list; chip; chip = chip->next) {
         wrote += write(out_fd, &chip->chipset, sizeof(uint32_t));
         wrote += write(out_fd, &chip->platform, sizeof(uint32_t));
-        wrote += write(out_fd, &chip->subtype, sizeof(uint32_t));
         wrote += write(out_fd, &chip->revNum, sizeof(uint32_t));
         if (chip->master->master_offset != 0) {
             wrote += write(out_fd, &chip->master->master_offset, sizeof(uint32_t));
diff --git a/dtbtool/dtbtool.txt b/dtbtool/dtbtool.txt
index b48e4bf..e738ef8 100644
--- a/dtbtool/dtbtool.txt
+++ b/dtbtool/dtbtool.txt
@@ -1,4 +1,4 @@
-Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+Copyright (c) 2012, The Linux Foundation. All rights reserved.
 
 Redistribution and use in source form and compiled forms (SGML, HTML,
 PDF, PostScript, RTF and so forth) with or without modification, are
@@ -33,7 +33,6 @@ Android - Table of Device Tree
 
 0) Document revision
    v1.0 - Initial version (dng)
-   v1.1 - Add v2 format to allow subtype (dng)
 
 1) Android boot image:
 ----------------------
@@ -73,15 +72,13 @@ Android - Table of Device Tree
    x      +------------------+
    |      | MAGIC ("QCDT")   |   4B
    |      +------------------+
- header   | VERSION          |   uint32 (version 2)
+ header   | VERSION          |   uint32 (initial version 1)
    |      +------------------+
    |      | num of DTBs      |   uint32 (number of DTB entries)
    x      +------------------+
    |      | platform id #1   |   uint32 (e.g. ID for MSM8974)
    |      +------------------+
    |      | variant id #1    |   uint32 (e.g. ID for CDP, MTP)
-   |      +------------------+
-   |      | subtype id #1    |   uint32 (e.g. ID for subtype) (QCDT v2)
  device   +------------------+
   #1      | soc rev #1       |   uint32 (e.g. MSM8974 v2)
  entry    +------------------+
@@ -98,10 +95,8 @@ Android - Table of Device Tree
    |      +------------------+
   device  | variant id #Z    |   uint32 (e.g. ID for CDP, MTP)
   #Z      +------------------+
-  entry   | variant id #Z    |   uint32 (e.g. ID for subtype) (QCDT v2)
+  entry   | soc rev #Z       |   uint32 (e.g. MSM8974 v2)
   (last)  +------------------+
-   |      | soc rev #Z       |   uint32 (e.g. MSM8974 v2)
-   |      +------------------+
    |      | offset #Z        |   uint32 (byte offset from start/before MAGIC
    x      +------------------+           to DTB entry)
           | 0 ("zero")       |   uint32 (end of list delimiter)
@@ -127,34 +122,25 @@ Android - Table of Device Tree
 3) Operations
 -------------
 3.1) Build-time:
-  1) Each DTS per device will add a "qcom,msm-id" entry
+  1) Each DTS per device will add a "qcom,msm-id" triplet
      e.g. for msm8974-sim.dts, add
-            qcom,msm-id = <x y z>;
-          or
-            qcom,msm-id = <x z>;
-            qcom,board-id = <y y'>;
-     x  = ID for msm8974
-     y  = ID for CDP, MTP, etc.
-     y' = ID for subtype (assumed zero if absent)
-     z  = ID for soc revision
-     The entry can optionally be an array:
-         qcom,msm-id = <x1 y1 z1>, <x2 y2 z2>, ...;
-       or
-         qcom,msm-id = <x1 z1>, <x2 z2>, ...;
-         qcom,board-id = <y1 y1'>, ...;
-     Note that qcom,msm-id and qcom,board-id are not matched
-     pairs.
+          qcom,msm-id = <x y z>;
+     x = ID for msm8974
+     y = ID for CDP, MTP, etc.
+     z = ID for soc revision
+     The triplet can optionally be an array of triplets:
+         qcom,msm-id = <x1, y1, z1>, <x2, y2, z2>, ...;
   2) Kernel compile will generate the DTB
   3) Android build will run a new tool (dtbTool)
      a) scan the DTB output directory for all compiled DTB
-     b) decompile the DTB for "qcom,msm-id"/"qcom,board-id"
+     b) decompile the DTB for "qcom,msm-id"
      c) generate the QC table of device tree in sorted
-        order (platform, variant, subtype, soc rev)
+        order (platform, variant, soc rev)
      d) modified mkbootimg will merge new table of DT
 
 3.2) Run-time:
-  1) LK bootloader will obtain MSM id/variant/subtype/soc rev
-     info either from early bootloaders or via other means
+  1) LK bootloader will obtain MSM id/variant/soc rev info
+     either from early bootloaders or via other means
   2) LK bootloader will check entries #10 for non-zero
      value (set to zero for standard boot.img).  If the
      value is non-zero, refer to page section after
@@ -166,8 +152,7 @@ Android - Table of Device Tree
      entry.  Search order is:
      1) platform ID exact match
      2) variant ID exact match
-     3) subtype ID exact match
-     4) select the highest soc rev in QCDT that is
+     3) select the highest soc rev in QCDT that is
         equal to or lower than the runtime detected soc rev
   6) Load the matching DTB blob to the tags addr
   7) LK pass the correct DTB to the kernel
-- 
1.7.9.5

